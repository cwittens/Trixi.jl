docs/literate/src/files/hohqmesh_tutorial.jl:25:# This package provides a Julia wrapper for the HOHQMesh generator that allows users to easily create mesh
docs/literate/src/files/hohqmesh_tutorial.jl:158:# The first three blocks of information are wrapped within a `CONTROL_INPUT` environment block as they define the
docs/literate/src/files/structured_mesh_mapping.jl:177:error_density = let u = Trixi.wrap_array(sol.u[end], semi)
docs/literate/src/files/behind_the_scenes_simulation_setup_plots/src/semidiscretize_structure_figure.jl:33:annotate!(-1.5, -13.5, ("wrap_array(u_ode, semi)", 10, :black, :center))
docs/literate/src/files/behind_the_scenes_simulation_setup_plots/src/semidiscretize_structure_figure.jl:34:annotate!(-2.2, -15.2, ("to simplify processing, it wraps the 1D array u_ode created in the allocate_coefficients function in
docs/literate/src/files/behind_the_scenes_simulation_setup_plots/src/semidiscretize_structure_figure.jl:43:saves in the wrapped u_ode", 9, :black, :left))
docs/literate/src/files/differentiable_programming.jl:200:# which we want to perform the linearization. Next, we wrap the RHS evaluation inside a closure
docs/literate/src/files/differentiable_programming.jl:309:# wrap everything in another function).
docs/literate/src/files/custom_semidiscretization.jl:20:# In particular, a spatial semidiscretization can be wrapped in an ODE problem
docs/literate/src/files/custom_semidiscretization.jl:25:# For a [`SemidiscretizationHyperbolic`](@ref), the `ODEProblem` wraps
docs/literate/src/files/custom_semidiscretization.jl:73:# We wrap everything in in a semidiscretization and pass the source
docs/literate/src/files/custom_semidiscretization.jl:78:# source terms must be wrapped in an `SVector` - even if we consider
docs/literate/src/files/custom_semidiscretization.jl:197:# wrapper of a standard semidiscretization of Trixi.jl and the current
docs/literate/src/files/custom_semidiscretization.jl:245:# semidiscretization provided by Trixi.jl wrapped in our custom
docs/literate/src/files/custom_semidiscretization.jl:269:# wrapped semidiscretization.
docs/literate/src/files/custom_semidiscretization.jl:273:        wrapped_semi = getfield(semi, :semi)
docs/literate/src/files/custom_semidiscretization.jl:274:        wrapped_semi.performance_counter
docs/literate/src/files/custom_semidiscretization.jl:281:# calculations. We also need to forward them to the wrapped
docs/literate/src/files/behind_the_scenes_simulation_setup.jl:160:# The purpose of the [`semidiscretize`](@ref) function is to wrap the semidiscretization as an
docs/literate/src/files/behind_the_scenes_simulation_setup.jl:180:#   of elements. Then, during the solving process the same memory is reused by `unsafe_wrap`ping
docs/literate/src/files/behind_the_scenes_simulation_setup.jl:183:# - `wrap_array(u_ode, semi)`
docs/literate/src/files/behind_the_scenes_simulation_setup.jl:189:#   This is why the `u_ode` vector is wrapped by the `wrap_array` function using `unsafe_wrap`
docs/literate/src/files/behind_the_scenes_simulation_setup.jl:204:#   Now the variable `u`, intended to store solutions, has been allocated and wrapped, it is time
docs/literate/src/files/adding_new_scalar_equations.jl:51:# We wrap the return value of the `initial_condition_sine` inside an `SVector` since that's the approach
docs/src/meshes/dgmulti_mesh.md:19:meshes constructed using [Triangulate.jl](https://github.com/JuliaGeometry/Triangulate.jl), a wrapper
docs/src/meshes/dgmulti_mesh.md:105:## `DGMultiMesh` wrapper type
docs/src/meshes/unstructured_quad_mesh.md:9:wrap numerical fluxes implemented only for Cartesian meshes. This simplifies
docs/src/meshes/p4est_mesh.md:12:wrap numerical fluxes implemented only for Cartesian meshes. This simplifies
docs/src/meshes/p4est_mesh.md:99:For example, the neighbor connectivity is created in the mesh constructor using the wrapper `read_inp_p4est` function.
docs/src/meshes/structured_mesh.md:11:wrap numerical fluxes implemented only for Cartesian meshes. This simplifies
docs/src/conventions.md:79:## Array types and wrapping
docs/src/conventions.md:85:in form of comments describing `Trixi.wrap_array` and `Trixi.wrap_array_native`
docs/src/conventions.md:87:The flexibility introduced by this possible wrapping enables additional
docs/src/conventions.md:92:and wrapped arrays mainly used internally.
docs/src/conventions.md:97:Methods either accept arrays visible to the time integrator or wrapped arrays
docs/src/conventions.md:100:  solution must be a `u_ode` that needs to be  wrapped via `wrap_array(u_ode, semi)`
docs/src/conventions.md:101:  (or `wrap_array_native(u_ode, semi)`) for further processing.
docs/src/conventions.md:103:  it is already wrapped via `wrap_array` (or `wrap_array_native`).
docs/src/conventions.md:106:- `wrap_array` should be used as default option. `wrap_array_native` should only
docs/src/overview.md:78:In particular, a spatial semidiscretization can be wrapped in an ODE problem
docs/src/overview.md:79:using [`semidiscretize`](@ref), which returns an `ODEProblem`. This `ODEProblem` is a wrapper
docs/src/parallelization.md:200:   [documentation of MPI.jl](https://juliaparallel.org/MPI.jl/v0.20/usage/#Julia-wrapper-for-mpiexec)
examples/paper_self_gravitating_gas_dynamics/elixir_eulergravity_jeans_instability.jl:126:    u_gravity = Trixi.wrap_array(semi.cache.u_ode, semi.semi_gravity)
examples/tree_2d_dgsem/elixir_shallowwater_ec.jl:82:u = Trixi.wrap_array(ode.u0, semi)
examples/tree_2d_dgsem/elixir_advection_callbacks.jl:75:# This method is used to wrap an `ExampleStepCallback` inside a `DiscreteCallback`
examples/tree_2d_dgsem/Manifest.toml:420:[[deps.ExceptionUnwrapping]]
examples/tree_2d_dgsem/Manifest.toml:673:deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
examples/tree_2d_dgsem/elixir_shallowwater_well_balanced.jl:81:u = Trixi.wrap_array(ode.u0, semi)
examples/tree_2d_dgsem/elixir_shallowwater_well_balanced_wall.jl:84:u = Trixi.wrap_array(ode.u0, semi)
examples/p4est_2d_dgsem/Manifest.toml:418:[[deps.ExceptionUnwrapping]]
examples/p4est_2d_dgsem/Manifest.toml:670:deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
examples/unstructured_2d_dgsem/elixir_shallowwater_ec.jl:82:u = Trixi.wrap_array(ode.u0, semi)
examples/unstructured_2d_dgsem/elixir_shallowwater_well_balanced.jl:80:u = Trixi.wrap_array(ode.u0, semi)
examples/unstructured_2d_dgsem/elixir_shallowwater_ec_float32.jl:87:u = Trixi.wrap_array(ode.u0, semi)
examples/unstructured_2d_dgsem/elixir_shallowwater_ec_shockcapturing.jl:91:u = Trixi.wrap_array(ode.u0, semi)
examples/tree_3d_dgsem/Manifest.toml:420:[[deps.ExceptionUnwrapping]]
examples/tree_3d_dgsem/Manifest.toml:673:deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
examples/structured_2d_dgsem/Manifest.toml:418:[[deps.ExceptionUnwrapping]]
examples/structured_2d_dgsem/Manifest.toml:670:deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
examples/structured_2d_dgsem/elixir_shallowwater_well_balanced.jl:84:u = Trixi.wrap_array(ode.u0, semi)
ext/TrixiMakieExt.jl:17:             wrap_array_native, mesh_equations_solver_cache
ext/TrixiMakieExt.jl:285:    iplot(wrap_array_native(u, semi), mesh_equations_solver_cache(semi)...; kwargs...)
src/semidiscretization/semidiscretization_euler_gravity.jl:223:    u_euler = wrap_array(u_ode, semi_euler)
src/semidiscretization/semidiscretization_euler_gravity.jl:224:    du_euler = wrap_array(du_ode, semi_euler)
src/semidiscretization/semidiscretization_euler_gravity.jl:225:    u_gravity = wrap_array(cache.u_ode, semi_gravity)
src/semidiscretization/semidiscretization_euler_gravity.jl:270:    u_euler = wrap_array(u_ode, semi_euler)
src/semidiscretization/semidiscretization_euler_gravity.jl:271:    u_gravity = wrap_array(cache.u_ode, semi_gravity)
src/semidiscretization/semidiscretization_euler_gravity.jl:272:    du_gravity = wrap_array(cache.du_ode, semi_gravity)
src/semidiscretization/semidiscretization_euler_gravity.jl:326:    du_gravity = wrap_array(du_ode, semi_gravity)
src/semidiscretization/semidiscretization_euler_gravity.jl:381:    du_gravity = wrap_array(du_ode, semi_gravity)
src/semidiscretization/semidiscretization_euler_gravity.jl:511:    u_euler = wrap_array_native(u_ode, semi.semi_euler)
src/semidiscretization/semidiscretization_euler_gravity.jl:517:    u_gravity = wrap_array_native(semi.cache.u_ode, semi.semi_gravity)
src/semidiscretization/semidiscretization.jl:43:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization.jl:60:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization.jl:157:    u = wrap_array(u_ode, semi)
src/semidiscretization/semidiscretization.jl:185:    # wrap the linear operator
src/semidiscretization/semidiscretization.jl:353:    u = wrap_array(u_ode, semi)
src/semidiscretization/semidiscretization.jl:372:# Then, we would need to wrap an Array inside something from PaddedMatrices.jl inside
src/semidiscretization/semidiscretization.jl:377:# which can be `resize!`ed for AMR. Then, we have to wrap these `Vector`s inside
src/semidiscretization/semidiscretization.jl:378:# Trixi.jl as our favorite multidimensional array type. We need to do this wrapping
src/semidiscretization/semidiscretization.jl:382:# This wrapping will also allow us to experiment more easily with additional
src/semidiscretization/semidiscretization.jl:383:# kinds of wrapping, e.g. HybridArrays.jl or PaddedMatrices.jl to inform the
src/semidiscretization/semidiscretization.jl:394:# Under the hood, `wrap_array(u_ode, mesh, equations, solver, cache)` might
src/semidiscretization/semidiscretization.jl:395:# (and probably will) use `unsafe_wrap`. Hence, you have to remember to
src/semidiscretization/semidiscretization.jl:396:# `GC.@preserve` temporaries that are only used indirectly via `wrap_array`
src/semidiscretization/semidiscretization.jl:400:function wrap_array(u_ode, semi::AbstractSemidiscretization)
src/semidiscretization/semidiscretization.jl:401:    wrap_array(u_ode, mesh_equations_solver_cache(semi)...)
src/semidiscretization/semidiscretization.jl:404:# Like `wrap_array`, but guarantees to return a plain `Array`, which can be better
src/semidiscretization/semidiscretization.jl:406:function wrap_array_native(u_ode, semi::AbstractSemidiscretization)
src/semidiscretization/semidiscretization.jl:407:    wrap_array_native(u_ode, mesh_equations_solver_cache(semi)...)
src/semidiscretization/semidiscretization.jl:418:# - wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_euler_acoustics.jl:178:    du_acoustics = wrap_array(du_ode, semi_acoustics)
src/semidiscretization/semidiscretization_hyperbolic.jl:396:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic.jl:414:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic.jl:415:    du = wrap_array(du_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl:254:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl:301:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl:302:    du = wrap_array(du_ode, mesh, equations, solver, cache)
src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl:317:    u = wrap_array(u_ode, mesh, equations_parabolic, solver, cache_parabolic)
src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl:318:    du = wrap_array(du_ode, mesh, equations_parabolic, solver, cache_parabolic)
src/semidiscretization/semidiscretization_coupled.jl:583:    u_other = wrap_array(u_ode_other, mesh_other, equations_other, solver_other,
src/meshes/structured_mesh.jl:148:# An internal function wrapping `CodeTracking.code_string` with additional
src/meshes/t8code_mesh.jl:107:Main mesh constructor for the `T8codeMesh` wrapping around a given t8code
src/meshes/t8code_mesh.jl:144:            # Note, `vertices = unsafe_wrap(Array, vertices_pointer, (3, 1 << NDIMS))`
src/meshes/t8code_mesh.jl:184:            # Note, `vertices = unsafe_wrap(Array, vertices_pointer, (3, 1 << NDIMS))`
src/meshes/t8code_mesh.jl:654:function adapt_callback_wrapper(forest,
src/meshes/t8code_mesh.jl:664:    elements = unsafe_wrap(Array, elements_ptr, num_elements)
src/meshes/t8code_mesh.jl:722:                            @t8_adapt_callback(adapt_callback_wrapper),
src/meshes/t8code_mesh.jl:870:                dual_faces = unsafe_wrap(Array, dual_faces_ref[], num_neighbors)
src/meshes/t8code_mesh.jl:871:                neighbor_ielements = unsafe_wrap(Array, pelement_indices_ref[],
src/meshes/t8code_mesh.jl:873:                neighbor_leaves = unsafe_wrap(Array, pneighbor_leaves_ref[], num_neighbors)
src/meshes/t8code_mesh.jl:1051:                dual_faces = unsafe_wrap(Array, dual_faces_ref[], num_neighbors)
src/meshes/t8code_mesh.jl:1052:                neighbor_ielements = unsafe_wrap(Array, pelement_indices_ref[],
src/meshes/t8code_mesh.jl:1054:                neighbor_leaves = unsafe_wrap(Array, pneighbor_leaves_ref[], num_neighbors)
src/meshes/p4est_mesh.jl:454:    # These need to be of the type Int for unsafe_wrap below to work
src/meshes/p4est_mesh.jl:459:    vertices = unsafe_wrap(Array, connectivity_pw.vertices, (3, n_vertices))
src/meshes/p4est_mesh.jl:512:    # These need to be of the type Int for unsafe_wrap below to work
src/meshes/p4est_mesh.jl:516:    vertices = unsafe_wrap(Array, connectivity_pw.vertices, (3, n_vertices))
src/meshes/p4est_mesh.jl:517:    tree_to_vertex = unsafe_wrap(Array, connectivity_pw.tree_to_vertex,
src/meshes/p4est_mesh.jl:1755:    return unsafe_wrap(Array, mesh.p4est.global_first_quadrant, mpi_nranks() + 1)
src/meshes/p4est_mesh.jl:1855:    quadrants = unsafe_wrap_quadrants(quadrants_ptr, p4est)
src/meshes/p4est_mesh.jl:1875:function unsafe_wrap_quadrants(quadrants_ptr, ::Ptr{p4est_t})
src/meshes/p4est_mesh.jl:1876:    unsafe_wrap(Array, quadrants_ptr, 4)
src/meshes/p4est_mesh.jl:1879:function unsafe_wrap_quadrants(quadrants_ptr, ::Ptr{p8est_t})
src/meshes/p4est_mesh.jl:1880:    unsafe_wrap(Array, quadrants_ptr, 8)
src/meshes/p4est_mesh.jl:1947:    tree_pw = load_pointerwrapper_tree(info_pw.p4est, info_pw.treeid[] + 1)
src/meshes/p4est_mesh.jl:2036:        tree_pw = load_pointerwrapper_tree(info_pw.p4est, info_pw.treeid[] + 1)
src/meshes/dgmulti_meshes.jl:11:`DGMultiMesh` describes a mesh type which wraps `StartUpDG.MeshData` and `boundary_faces` in a
src/callbacks_step/amr_dg2d.jl:25:        # Use `wrap_array_native` instead of `wrap_array` since MPI might not interact
src/callbacks_step/amr_dg2d.jl:27:        old_u = wrap_array_native(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:35:        u = wrap_array_native(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:105:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:123:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:299:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:317:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:493:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg2d.jl:508:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:197:    # Note that we don't `wrap_array` the vector `u_ode` to be able to `resize!`
src/callbacks_step/amr.jl:206:    # Note that we don't `wrap_array` the vector `u_ode` to be able to `resize!`
src/callbacks_step/amr.jl:225:    u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:375:    u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:521:    tree_pw = load_pointerwrapper_tree(info_pw.p4est, info_pw.treeid[] + 1)
src/callbacks_step/amr.jl:549:    u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:615:                global_first_quadrant = unsafe_wrap(Array,
src/callbacks_step/amr.jl:655:    u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:721:                global_first_quadrant = unsafe_wrap(Array,
src/callbacks_step/amr.jl:747:    u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr.jl:928:    tree_pw = load_pointerwrapper_tree(info_pw.p4est, info_pw.treeid[] + 1)
src/callbacks_step/save_restart_dg.jl:56:    u = wrap_array_native(u_ode, mesh, equations, dg, cache)
src/callbacks_step/save_restart_dg.jl:228:    u = wrap_array_native(u_ode, mesh, equations, dg, cache)
src/callbacks_step/save_restart_dg.jl:277:    u = wrap_array_native(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:34:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:52:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:215:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:233:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:423:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg3d.jl:438:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/save_solution.jl:239:    u = wrap_array_native(u_ode, mesh, equations, solver, cache)
src/callbacks_step/stepsize.jl:86:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/stepsize.jl:107:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/lbm_collision.jl:56:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/averaging.jl:75:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/averaging.jl:94:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/averaging.jl:95:    u_prev = wrap_array(u_prev_ode, mesh, equations, solver, cache)
src/callbacks_step/save_restart.jl:122:    u = wrap_array_native(u_ode, mesh, equations, solver, cache)
src/callbacks_step/euler_acoustics_coupling.jl:154:    u_acoustics = wrap_array(u_ode, semi_acoustics)
src/callbacks_step/euler_acoustics_coupling.jl:200:    u_acoustics = wrap_array(integrator_acoustics.u, semi)
src/callbacks_step/euler_acoustics_coupling.jl:201:    u_euler = wrap_array(integrator_euler.u, semi_euler)
src/callbacks_step/amr_dg1d.jl:24:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg1d.jl:37:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg1d.jl:161:        old_u = wrap_array(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg1d.jl:174:        u = wrap_array(u_ode, mesh, equations, dg, cache)
src/callbacks_step/callbacks_step.jl:20:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/analysis.jl:338:        u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/analysis.jl:339:        du = wrap_array(du_ode, mesh, equations, solver, cache)
src/callbacks_step/analysis.jl:553:    for tree in unsafe_wrap_sc(p4est_tree_t, mesh.p4est.trees)
src/callbacks_step/time_series.jl:194:            u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_step/amr_dg.jl:32:        # Use `wrap_array_native` instead of `wrap_array` since MPI might not interact
src/callbacks_step/amr_dg.jl:34:        old_u = wrap_array_native(old_u_ode, mesh, equations, dg, cache)
src/callbacks_step/amr_dg.jl:42:        u = wrap_array_native(u_ode, mesh, equations, dg, cache)
src/callbacks_step/steady_state.jl:59:    u = wrap_array(u_ode, semi)
src/callbacks_step/steady_state.jl:60:    du = wrap_array(get_du(integrator), semi)
src/visualization/types.jl:164:# Generic PlotMesh wrapper type.
src/visualization/types.jl:231:    PlotData2D(wrap_array_native(u_ode, semi),
src/visualization/types.jl:238:    PlotData2DTriangulated(wrap_array_native(u_ode, semi),
src/visualization/types.jl:472:    # wrap solution in ScalarData struct for recipe dispatch
src/visualization/types.jl:512:    # wrap solution in ScalarData struct for recipe dispatch
src/visualization/types.jl:545:    PlotData1D(wrap_array_native(u_ode, semi),
src/visualization/recipes_plots.jl:260:    # Since `data` is simply a ScalarData wrapper around the actual plot data, we pass in
src/time_integration/paired_explicit_runge_kutta/methods_PERK2.jl:250:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/solvers/dgsem_structured/dg_3d_compressible_euler.jl:14:# We do not wrap this code in `@muladd begin ... end` block. Optimizations like
src/solvers/dgsem_structured/dg_3d_compressible_euler.jl:17:# We specialize on `PtrArray` since these will be returned by `Trixi.wrap_array`
src/solvers/dgsem_structured/dg_2d_compressible_euler.jl:14:# We do not wrap this code in `@muladd begin ... end` block. Optimizations like
src/solvers/dgsem_structured/dg_2d_compressible_euler.jl:17:# We specialize on `PtrArray` since these will be returned by `Trixi.wrap_array`
src/solvers/dgsem_p4est/containers_2d.jl:68:    trees = unsafe_wrap_sc(p4est_tree_t, mesh.p4est.trees)
src/solvers/dgsem_p4est/containers_2d.jl:72:        quadrants = unsafe_wrap_sc(p4est_quadrant_t, trees[tree].quadrants)
src/solvers/dgsem_p4est/containers_2d.jl:118:    trees = unsafe_wrap_sc(p4est_tree_t, mesh.parent.p4est.trees)[mesh.cell_ids]
src/solvers/dgsem_p4est/containers_2d.jl:122:        quadrants = unsafe_wrap_sc(p4est_quadrant_t, trees[tree].quadrants)
src/solvers/dgsem_p4est/containers_parallel.jl:32:    mpi_interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers_parallel.jl:57:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers_parallel.jl:116:    mpi_mortars.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers_parallel.jl:124:    mpi_mortars.node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, capacity))
src/solvers/dgsem_p4est/containers_parallel.jl:128:    mpi_mortars.normal_directions = unsafe_wrap(Array, pointer(_normal_directions),
src/solvers/dgsem_p4est/containers_parallel.jl:149:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers_parallel.jl:157:    node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, n_mpi_mortars))
src/solvers/dgsem_p4est/containers_parallel.jl:162:    normal_directions = unsafe_wrap(Array, pointer(_normal_directions),
src/solvers/dgsem_p4est/containers_parallel.jl:320:        sides_pw = (load_pointerwrapper_side(info_pw, 1),
src/solvers/dgsem_p4est/containers_parallel.jl:321:                    load_pointerwrapper_side(info_pw, 2))
src/solvers/dgsem_p4est/containers_parallel.jl:401:    tree_pw = load_pointerwrapper_tree(mesh.p4est, sides_pw[local_side].treeid[] + 1)
src/solvers/dgsem_p4est/containers_parallel.jl:429:    trees_pw = (load_pointerwrapper_tree(mesh.p4est, sides_pw[1].treeid[] + 1),
src/solvers/dgsem_p4est/containers_parallel.jl:430:                load_pointerwrapper_tree(mesh.p4est, sides_pw[2].treeid[] + 1))
src/solvers/dgsem_p4est/containers_parallel.jl:496:        sides_pw = (load_pointerwrapper_side(info_pw, 1),
src/solvers/dgsem_p4est/containers_parallel.jl:497:                    load_pointerwrapper_side(info_pw, 2))
src/solvers/dgsem_p4est/containers.jl:45:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_p4est/containers.jl:56:    elements.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_p4est/containers.jl:61:    elements.jacobian_matrix = unsafe_wrap(Array, pointer(_jacobian_matrix),
src/solvers/dgsem_p4est/containers.jl:66:    elements.contravariant_vectors = unsafe_wrap(Array, pointer(_contravariant_vectors),
src/solvers/dgsem_p4est/containers.jl:70:    elements.inverse_jacobian = unsafe_wrap(Array, pointer(_inverse_jacobian),
src/solvers/dgsem_p4est/containers.jl:75:    elements.surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_p4est/containers.jl:93:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_p4est/containers.jl:98:    jacobian_matrix = unsafe_wrap(Array, pointer(_jacobian_matrix),
src/solvers/dgsem_p4est/containers.jl:103:    contravariant_vectors = unsafe_wrap(Array, pointer(_contravariant_vectors),
src/solvers/dgsem_p4est/containers.jl:107:    inverse_jacobian = unsafe_wrap(Array, pointer(_inverse_jacobian),
src/solvers/dgsem_p4est/containers.jl:114:    surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_p4est/containers.jl:157:    interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:162:    interfaces.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids), (2, capacity))
src/solvers/dgsem_p4est/containers.jl:165:    interfaces.node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, capacity))
src/solvers/dgsem_p4est/containers.jl:181:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:186:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids), (2, n_interfaces))
src/solvers/dgsem_p4est/containers.jl:189:    node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, n_interfaces))
src/solvers/dgsem_p4est/containers.jl:232:    boundaries.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:256:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:284:    side_pw = load_pointerwrapper_side(info_pw)
src/solvers/dgsem_p4est/containers.jl:286:    tree_pw = load_pointerwrapper_tree(mesh.p4est, side_pw.treeid[] + 1)
src/solvers/dgsem_p4est/containers.jl:362:    mortars.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:367:    mortars.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_p4est/containers.jl:371:    mortars.node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, capacity))
src/solvers/dgsem_p4est/containers.jl:387:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_p4est/containers.jl:392:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_p4est/containers.jl:396:    node_indices = unsafe_wrap(Array, pointer(_node_indices), (2, n_mortars))
src/solvers/dgsem_p4est/containers.jl:495:        sides_pw = (load_pointerwrapper_side(info_pw, 1),
src/solvers/dgsem_p4est/containers.jl:496:                    load_pointerwrapper_side(info_pw, 2))
src/solvers/dgsem_p4est/containers.jl:550:    trees_pw = (load_pointerwrapper_tree(mesh.p4est, sides_pw[1].treeid[] + 1),
src/solvers/dgsem_p4est/containers.jl:551:                load_pointerwrapper_tree(mesh.p4est, sides_pw[2].treeid[] + 1))
src/solvers/dgsem_p4est/containers.jl:580:    side_pw = load_pointerwrapper_side(info_pw)
src/solvers/dgsem_p4est/containers.jl:582:    tree_pw = load_pointerwrapper_tree(mesh.p4est, side_pw.treeid[] + 1)
src/solvers/dgsem_p4est/containers.jl:615:    trees_pw = (load_pointerwrapper_tree(mesh.p4est, sides_pw[1].treeid[] + 1),
src/solvers/dgsem_p4est/containers.jl:616:                load_pointerwrapper_tree(mesh.p4est, sides_pw[2].treeid[] + 1))
src/solvers/dgsem_p4est/containers.jl:670:        sides_pw = (load_pointerwrapper_side(info_pw, 1),
src/solvers/dgsem_p4est/containers.jl:671:                    load_pointerwrapper_side(info_pw, 2))
src/solvers/dgsem_p4est/dg_parallel.jl:271:    n_elements_by_rank = vcat(Int.(unsafe_wrap(Array, mesh.p4est.global_first_quadrant,
src/solvers/dgsem_p4est/dg_parallel.jl:388:        sides_pw = (load_pointerwrapper_side(info_pw, 1),
src/solvers/dgsem_p4est/dg_parallel.jl:389:                    load_pointerwrapper_side(info_pw, 2))
src/solvers/dgsem_p4est/dg_parallel.jl:403:            local_tree_pw = load_pointerwrapper_tree(mesh.p4est,
src/solvers/dgsem_p4est/dg_parallel.jl:410:            proc_offsets = unsafe_wrap(Array,
src/solvers/dgsem_p4est/dg_parallel.jl:450:            trees_pw = (load_pointerwrapper_tree(mesh.p4est, sides_pw[1].treeid[] + 1),
src/solvers/dgsem_p4est/dg_parallel.jl:451:                        load_pointerwrapper_tree(mesh.p4est, sides_pw[2].treeid[] + 1))
src/solvers/dgsem_p4est/dg_parallel.jl:456:            proc_offsets = unsafe_wrap(Array,
src/solvers/dgsem_p4est/containers_3d.jl:47:    trees = unsafe_wrap_sc(p8est_tree_t, mesh.p4est.trees)
src/solvers/dgsem_p4est/containers_3d.jl:51:        quadrants = unsafe_wrap_sc(p8est_quadrant_t, trees[tree].quadrants)
src/solvers/fdsbp_tree/fdsbp_3d.jl:138:        # f_minus_plus_element wraps the storage provided by f_minus_element and
src/solvers/fdsbp_tree/fdsbp_2d.jl:131:        # f_minus_plus_element wraps the storage provided by f_minus_element and
src/solvers/fdsbp_tree/fdsbp_1d.jl:122:        # f_minus_plus_element wraps the storage provided by f_minus_element and
src/solvers/fdsbp_unstructured/fdsbp_2d.jl:127:        # f_minus_plus_element wraps the storage provided by f_minus_element and
src/solvers/dgsem_tree/containers_2d.jl:26:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/containers_2d.jl:37:    elements.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_2d.jl:41:    elements.surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_2d.jl:59:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_2d.jl:63:    surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_2d.jl:165:    interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:169:    interfaces.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_2d.jl:183:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:187:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_2d.jl:332:    boundaries.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:336:    boundaries.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_2d.jl:356:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:366:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_2d.jl:536:    mortars.u_upper = unsafe_wrap(Array, pointer(_u_upper),
src/solvers/dgsem_tree/containers_2d.jl:540:    mortars.u_lower = unsafe_wrap(Array, pointer(_u_lower),
src/solvers/dgsem_tree/containers_2d.jl:544:    mortars.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_2d.jl:560:    u_upper = unsafe_wrap(Array, pointer(_u_upper),
src/solvers/dgsem_tree/containers_2d.jl:564:    u_lower = unsafe_wrap(Array, pointer(_u_lower),
src/solvers/dgsem_tree/containers_2d.jl:568:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_2d.jl:789:    mpi_interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:807:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_2d.jl:970:    mpi_mortars.u_upper = unsafe_wrap(Array, pointer(_u_upper),
src/solvers/dgsem_tree/containers_2d.jl:974:    mpi_mortars.u_lower = unsafe_wrap(Array, pointer(_u_lower),
src/solvers/dgsem_tree/containers_2d.jl:993:    u_upper = unsafe_wrap(Array, pointer(_u_upper),
src/solvers/dgsem_tree/containers_2d.jl:997:    u_lower = unsafe_wrap(Array, pointer(_u_lower),
src/solvers/dgsem_tree/containers_2d.jl:1295:    antidiffusive_flux1_L = unsafe_wrap(Array, pointer(_antidiffusive_flux1_L),
src/solvers/dgsem_tree/containers_2d.jl:1299:    antidiffusive_flux1_R = unsafe_wrap(Array, pointer(_antidiffusive_flux1_R),
src/solvers/dgsem_tree/containers_2d.jl:1304:    antidiffusive_flux2_L = unsafe_wrap(Array, pointer(_antidiffusive_flux2_L),
src/solvers/dgsem_tree/containers_2d.jl:1308:    antidiffusive_flux2_R = unsafe_wrap(Array, pointer(_antidiffusive_flux2_R),
src/solvers/dgsem_tree/containers_2d.jl:1327:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/containers_2d.jl:1336:    fluxes.antidiffusive_flux1_L = unsafe_wrap(Array, pointer(_antidiffusive_flux1_L),
src/solvers/dgsem_tree/containers_2d.jl:1340:    fluxes.antidiffusive_flux1_R = unsafe_wrap(Array, pointer(_antidiffusive_flux1_R),
src/solvers/dgsem_tree/containers_2d.jl:1344:    fluxes.antidiffusive_flux2_L = unsafe_wrap(Array, pointer(_antidiffusive_flux2_L),
src/solvers/dgsem_tree/containers_2d.jl:1348:    fluxes.antidiffusive_flux2_R = unsafe_wrap(Array, pointer(_antidiffusive_flux2_R),
src/solvers/dgsem_tree/containers_2d.jl:1374:    alpha = unsafe_wrap(Array, pointer(_alpha), (n_nodes, n_nodes, capacity))
src/solvers/dgsem_tree/containers_2d.jl:1376:    alpha1 = unsafe_wrap(Array, pointer(_alpha1), (n_nodes + 1, n_nodes, capacity))
src/solvers/dgsem_tree/containers_2d.jl:1378:    alpha2 = unsafe_wrap(Array, pointer(_alpha2), (n_nodes, n_nodes + 1, capacity))
src/solvers/dgsem_tree/containers_2d.jl:1384:        variable_bounds[key] = unsafe_wrap(Array, pointer(_variable_bounds[key]),
src/solvers/dgsem_tree/containers_2d.jl:1399:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/containers_2d.jl:1406:    container.alpha = unsafe_wrap(Array, pointer(_alpha), (n_nodes, n_nodes, capacity))
src/solvers/dgsem_tree/containers_2d.jl:1409:    container.alpha1 = unsafe_wrap(Array, pointer(_alpha1),
src/solvers/dgsem_tree/containers_2d.jl:1412:    container.alpha2 = unsafe_wrap(Array, pointer(_alpha2),
src/solvers/dgsem_tree/containers_2d.jl:1418:        container.variable_bounds[key] = unsafe_wrap(Array,
src/solvers/dgsem_tree/dg_3d_compressible_euler.jl:13:# We do not wrap this code in `@muladd begin ... end` block. Optimizations like
src/solvers/dgsem_tree/dg_3d_compressible_euler.jl:16:# We specialize on `PtrArray` since these will be returned by `Trixi.wrap_array`
src/solvers/dgsem_tree/container_viscous_1d.jl:31:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/container_viscous_1d.jl:39:    viscous_container.u_transformed = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_1d.jl:45:    viscous_container.gradients = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_1d.jl:51:    viscous_container.flux_viscous = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_2d.jl:39:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/container_viscous_2d.jl:49:    viscous_container.u_transformed = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_2d.jl:56:        viscous_container.gradients[dim] = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_2d.jl:62:        viscous_container.flux_viscous[dim] = unsafe_wrap(Array,
src/solvers/dgsem_tree/containers_1d.jl:26:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/containers_1d.jl:37:    elements.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_1d.jl:41:    elements.surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_1d.jl:59:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_1d.jl:63:    surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_1d.jl:159:    interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_1d.jl:163:    interfaces.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_1d.jl:177:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_1d.jl:181:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_1d.jl:309:    boundaries.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_1d.jl:313:    boundaries.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_1d.jl:333:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_1d.jl:343:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_3d.jl:26:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/containers_3d.jl:37:    elements.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_3d.jl:41:    elements.surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_3d.jl:60:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_3d.jl:65:    surface_flux_values = unsafe_wrap(Array, pointer(_surface_flux_values),
src/solvers/dgsem_tree/containers_3d.jl:171:    interfaces.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_3d.jl:175:    interfaces.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_3d.jl:189:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_3d.jl:193:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_3d.jl:329:    boundaries.u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_3d.jl:333:    boundaries.node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_3d.jl:353:    u = unsafe_wrap(Array, pointer(_u),
src/solvers/dgsem_tree/containers_3d.jl:363:    node_coordinates = unsafe_wrap(Array, pointer(_node_coordinates),
src/solvers/dgsem_tree/containers_3d.jl:551:    mortars.u_upper_left = unsafe_wrap(Array, pointer(_u_upper_left),
src/solvers/dgsem_tree/containers_3d.jl:555:    mortars.u_upper_right = unsafe_wrap(Array, pointer(_u_upper_right),
src/solvers/dgsem_tree/containers_3d.jl:559:    mortars.u_lower_left = unsafe_wrap(Array, pointer(_u_lower_left),
src/solvers/dgsem_tree/containers_3d.jl:563:    mortars.u_lower_right = unsafe_wrap(Array, pointer(_u_lower_right),
src/solvers/dgsem_tree/containers_3d.jl:567:    mortars.neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/containers_3d.jl:583:    u_upper_left = unsafe_wrap(Array, pointer(_u_upper_left),
src/solvers/dgsem_tree/containers_3d.jl:587:    u_upper_right = unsafe_wrap(Array, pointer(_u_upper_right),
src/solvers/dgsem_tree/containers_3d.jl:591:    u_lower_left = unsafe_wrap(Array, pointer(_u_lower_left),
src/solvers/dgsem_tree/containers_3d.jl:595:    u_lower_right = unsafe_wrap(Array, pointer(_u_lower_right),
src/solvers/dgsem_tree/containers_3d.jl:599:    neighbor_ids = unsafe_wrap(Array, pointer(_neighbor_ids),
src/solvers/dgsem_tree/container_viscous_3d.jl:43:# `unsafe_wrap`ping multi-dimensional `Array`s around the
src/solvers/dgsem_tree/container_viscous_3d.jl:54:    viscous_container.u_transformed = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_3d.jl:61:        viscous_container.gradients[dim] = unsafe_wrap(Array,
src/solvers/dgsem_tree/container_viscous_3d.jl:67:        viscous_container.flux_viscous[dim] = unsafe_wrap(Array,
src/solvers/dgsem_tree/dg_2d_compressible_euler.jl:61:# We do not wrap this code in `@muladd begin ... end` block. Optimizations like
src/solvers/dgsem_tree/dg_2d_compressible_euler.jl:64:# We specialize on `PtrArray` since these will be returned by `Trixi.wrap_array`
src/solvers/dgmulti/dg.jl:129:wrap_array(u_ode, mesh::DGMultiMesh, equations, dg::DGMulti, cache) = u_ode
src/solvers/dgmulti/dg.jl:130:wrap_array_native(u_ode, mesh::DGMultiMesh, equations, dg::DGMulti, cache) = u_ode
src/solvers/dg.jl:604:    # cf. wrap_array
src/solvers/dg.jl:609:@inline function wrap_array(u_ode::AbstractVector, mesh::AbstractMesh, equations,
src/solvers/dg.jl:623:    #     and other stuff that is only used indirectly via `wrap_array` afterwards!
src/solvers/dg.jl:649:        unsafe_wrap(Array{eltype(u_ode), ndims(mesh) + 2}, pointer(u_ode),
src/solvers/dg.jl:656:@inline function wrap_array(u_ode::AbstractVector, mesh::AbstractMesh, equations,
src/solvers/dg.jl:672:        unsafe_wrap(Array{eltype(u_ode), ndims(mesh) + 2}, pointer(u_ode),
src/solvers/dg.jl:679:@inline function wrap_array(u_ode::AbstractVector, mesh::AbstractMesh, equations,
src/solvers/dg.jl:681:    wrap_array_native(u_ode, mesh, equations, dg, cache)
src/solvers/dg.jl:684:# Like `wrap_array`, but guarantees to return a plain `Array`, which can be better
src/solvers/dg.jl:687:@inline function wrap_array_native(u_ode::AbstractVector, mesh::AbstractMesh, equations,
src/solvers/dg.jl:693:    unsafe_wrap(Array{eltype(u_ode), ndims(mesh) + 2}, pointer(u_ode),
src/auxiliary/p4est.jl:37:function unsafe_wrap_sc(::Type{T}, sc_array_ptr::Ptr{sc_array}) where {T}
src/auxiliary/p4est.jl:39:    return unsafe_wrap_sc(T, sc_array_obj)
src/auxiliary/p4est.jl:42:function unsafe_wrap_sc(::Type{T}, sc_array_obj::sc_array) where {T}
src/auxiliary/p4est.jl:45:    return unsafe_wrap(Array, Ptr{T}(array), elem_count)
src/auxiliary/p4est.jl:48:function unsafe_wrap_sc(::Type{T}, sc_array_pw::PointerWrapper{sc_array}) where {T}
src/auxiliary/p4est.jl:52:    return unsafe_wrap(Array, Ptr{T}(pointer(array)), elem_count)
src/auxiliary/p4est.jl:56:function load_pointerwrapper_sc(::Type{T}, sc_array::PointerWrapper{sc_array},
src/auxiliary/p4est.jl:261:function load_pointerwrapper_side(info::PointerWrapper{p4est_iter_face_info_t},
src/auxiliary/p4est.jl:263:    return load_pointerwrapper_sc(p4est_iter_face_side_t, info.sides, i)
src/auxiliary/p4est.jl:267:function load_pointerwrapper_side(info::PointerWrapper{p8est_iter_face_info_t},
src/auxiliary/p4est.jl:269:    return load_pointerwrapper_sc(p8est_iter_face_side_t, info.sides, i)
src/auxiliary/p4est.jl:274:function load_pointerwrapper_tree(p4est::PointerWrapper{p4est_t}, i::Integer = 1)
src/auxiliary/p4est.jl:275:    return load_pointerwrapper_sc(p4est_tree_t, p4est.trees, i)
src/auxiliary/p4est.jl:279:function load_pointerwrapper_tree(p8est::PointerWrapper{p8est_t}, i::Integer = 1)
src/auxiliary/p4est.jl:280:    return load_pointerwrapper_sc(p8est_tree_t, p8est.trees, i)
src/auxiliary/t8code.jl:107:    indicators = unsafe_wrap(Array, indicator_ptr, num_levels)
src/auxiliary/auxiliary.jl:208:    #     Look at the comments for `wrap_array` when considering to change this macro.
src/auxiliary/auxiliary.jl:312:This is a small wrapper of `Downloads.download(src_url, file_path)`
src/callbacks_stage/positivity_zhang_shu.jl:34:    u = wrap_array(u_ode, semi)
src/callbacks_stage/subcell_limiter_idp_correction.jl:47:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_stage/subcell_bounds_check.jl:39:    u = wrap_array(u_ode, mesh, equations, solver, cache)
src/callbacks_stage/entropy_bounded_limiter.jl:54:        u = wrap_array(u_ode, semi)
src/callbacks_stage/entropy_bounded_limiter.jl:55:        u_prev = wrap_array(integrator.uprev, semi)
test/Manifest.toml:567:[[deps.ExceptionUnwrapping]]
test/Manifest.toml:874:deps = ["Base64", "CodecZlib", "ConcurrentUtilities", "Dates", "ExceptionUnwrapping", "Logging", "LoggingExtras", "MbedTLS", "NetworkOptions", "OpenSSL", "Random", "SimpleBufferStream", "Sockets", "URIs", "UUIDs"]
test/test_unit.jl:1296:    # Define wrapper function for pressure in order to call default implementation
test/test_performance_specializations_2d.jl:24:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_2d.jl:27:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_2d.jl:28:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_2d.jl:63:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_2d.jl:66:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_2d.jl:67:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_2d.jl:103:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_2d.jl:106:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_2d.jl:107:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_2d.jl:142:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_2d.jl:145:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_2d.jl:146:        du = Trixi.wrap_array(du_ode, semi)
test/test_p4est_2d.jl:694:    u = Trixi.wrap_array(u_ode, semi)
test/test_p4est_2d.jl:695:    du = Trixi.wrap_array(du_ode, semi)
test/test_p4est_2d.jl:738:    u = Trixi.wrap_array(u_ode, semi)
test/test_p4est_2d.jl:739:    du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_3d.jl:24:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_3d.jl:27:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_3d.jl:28:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_3d.jl:63:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_3d.jl:66:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_3d.jl:67:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_3d.jl:103:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_3d.jl:106:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_3d.jl:107:        du = Trixi.wrap_array(du_ode, semi)
test/test_performance_specializations_3d.jl:142:    # Preserve original memory since it will be `unsafe_wrap`ped and might
test/test_performance_specializations_3d.jl:145:        u = Trixi.wrap_array(u_ode, semi)
test/test_performance_specializations_3d.jl:146:        du = Trixi.wrap_array(du_ode, semi)
test/test_trixi.jl:212:Similar to `@testset`, but wraps the code inside a temporary module to avoid
test/test_parabolic_2d.jl:738:    u = Trixi.wrap_array(u_ode, semi)
test/test_parabolic_2d.jl:739:    du = Trixi.wrap_array(du_ode, semi)
utils/trixi2tec.jl:96:    u = Trixi.wrap_array_native(u_ode, semi)
